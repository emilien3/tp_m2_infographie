#include <igl/readOFF.h>
#include <igl/opengl/glfw/Viewer.h>
#include <igl/cotmatrix.h>
#include <igl/massmatrix.h>
#include <igl/adjacency_list.h>
#include <igl/vertex_triangle_adjacency.h>
#include <Eigen/Sparse>
#include <Eigen/SparseLU>
#include <iostream>

int main()
{
    // =====================================
    // 1. CHARGEMENT DU MAILLAGE
    // =====================================
    
    Eigen::MatrixXd V; // Vertices (sommets)
    Eigen::MatrixXi F; // Faces (triangles)
    
    // Charger un maillage (remplacez par votre fichier)
    if (!igl::readOFF("../data/bunny.off", V, F)) {
        std::cerr << "Erreur: impossible de charger le maillage" << std::endl;
        return -1;
    }


    // =====================================
    // 2. SÃ‰LECTION DU VOISINAGE PAR ANNEAUX TOPOLOGIQUES
    // =====================================
    
    // Construire la liste d'adjacence
    std::vector<std::vector<int>> adjacency_list;
    igl::adjacency_list(F, adjacency_list);
    
    // Fonction pour obtenir les k-rings d'un sommet
    auto get_k_ring_neighbors = [&](int vertex_id, int k) -> std::set<int> {
        std::set<int> neighbors;
        std::set<int> current_ring = {vertex_id};
        
        for (int ring = 0; ring < k; ++ring) {
            std::set<int> next_ring;
            for (int v : current_ring) {
                for (int neighbor : adjacency_list[v]) {
                    if (neighbors.find(neighbor) == neighbors.end()) {
                        next_ring.insert(neighbor);
                    }
                }
            }
            neighbors.insert(current_ring.begin(), current_ring.end());
            current_ring = next_ring;
        }
        neighbors.insert(current_ring.begin(), current_ring.end());
        return neighbors;
    };
    
    // Exemple: obtenir les 2-rings du sommet 0
    int selected_vertex = 0;
    int k_rings = 2;
    std::set<int> neighborhood = get_k_ring_neighbors(selected_vertex, k_rings);
    
    std::cout << "Voisinage " << k_rings << "-rings du sommet " << selected_vertex 
              << ": " << neighborhood.size() << " sommets" << std::endl;

    // =====================================
    // 3. CALCUL DU LAPLACIEN COTANGENT (PAR DIFFUSION)
    // =====================================
    
    Eigen::SparseMatrix<double> L; // Matrice laplacienne
    Eigen::SparseMatrix<double> M; // Matrice de masse
    
    // Calculer la matrice laplacienne cotangent
    igl::cotmatrix(V, F, L);
    igl::massmatrix(V, F, igl::MASSMATRIX_TYPE_VORONOI, M);
    
    // Laplacien normalisÃ©: M^(-1) * L
    Eigen::SparseMatrix<double> Minv;
    Minv = M.cwiseInverse(); // Inverse des Ã©lÃ©ments diagonaux pour masse diagonale
    Eigen::SparseMatrix<double> L_normalized = Minv * L;
    
    // Calculer les valeurs du Laplacien pour chaque sommet
    Eigen::VectorXd laplacian_values = L_normalized * V.col(0); // Exemple sur coordonnÃ©e X
    
    std::cout << "Laplacien calculÃ© (diffusion) pour " << V.rows() << " sommets" << std::endl;

    // =====================================
    // 4. CALCUL DU LAPLACIEN PAR RÃ‰SOLUTION SYSTÃˆME LINÃ‰AIRE
    // =====================================
    
    // CrÃ©er un systÃ¨me linÃ©aire: L * x = b
    // Exemple: rÃ©soudre un problÃ¨me de Poisson avec conditions aux limites
    
    Eigen::VectorXd b = Eigen::VectorXd::Zero(V.rows());
    
    // DÃ©finir quelques conditions aux limites (exemple arbitraire)
    std::vector<int> boundary_vertices = {0, static_cast<int>( V.rows())/4, static_cast<int>(V.rows())/2, 3*static_cast<int>(V.rows())/4};
    for (int vid : boundary_vertices) {
        if (vid < V.rows()) {
            b(vid) = 1.0; // Valeur imposÃ©e
        }
    }
    
    // RÃ©soudre le systÃ¨me linÃ©aire L * x = b
    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;
    solver.analyzePattern(L);
    solver.factorize(L);
    
    Eigen::VectorXd solution;
    if (solver.info() == Eigen::Success) {
        solution = solver.solve(b);
        std::cout << "SystÃ¨me linÃ©aire rÃ©solu avec succÃ¨s" << std::endl;
    } else {
        std::cout << "Erreur lors de la rÃ©solution du systÃ¨me linÃ©aire" << std::endl;
        solution = Eigen::VectorXd::Zero(V.rows());
    }

    // =====================================
    // 5. VISUALISATION AVEC VARIATION DE COULEUR
    // =====================================
    
    // CrÃ©er le viewer
    igl::opengl::glfw::Viewer viewer;
    
    // DÃ©finir le maillage
    viewer.data().set_mesh(V, F);
    
    // Fonction pour visualiser les rÃ©sultats
    auto visualize_scalar_field = [&](const Eigen::VectorXd& values, const std::string& name) {
        // Normaliser les valeurs pour la couleur
        double min_val = values.minCoeff();
        double max_val = values.maxCoeff();
        
        Eigen::MatrixXd colors(V.rows(), 3);
        for (int i = 0; i < V.rows(); ++i) {
            double normalized = (values(i) - min_val) / (max_val - min_val);
            // Colormap: bleu -> vert -> rouge
            if (normalized < 0.5) {
                colors(i, 0) = 0.0;                    // Rouge
                colors(i, 1) = 2.0 * normalized;       // Vert
                colors(i, 2) = 1.0 - 2.0 * normalized; // Bleu
            } else {
                colors(i, 0) = 2.0 * (normalized - 0.5); // Rouge
                colors(i, 1) = 1.0 - 2.0 * (normalized - 0.5); // Vert
                colors(i, 2) = 0.0;                     // Bleu
            }
        }
        
        viewer.data().set_colors(colors);
        std::cout << "Affichage: " << name << " (min=" << min_val 
                  << ", max=" << max_val << ")" << std::endl;
    };
    
    // Callback pour changer entre les visualisations
    viewer.callback_key_down = [&](igl::opengl::glfw::Viewer& viewer, unsigned char key, int modifier) -> bool {
        switch (key) {
            case '1':
                visualize_scalar_field(laplacian_values, "Laplacien par diffusion");
                return true;
            case '2':
                visualize_scalar_field(solution, "Laplacien par systÃ¨me linÃ©aire");
                return true;
            case '3': {
                // Visualiser le voisinage sÃ©lectionnÃ©
                Eigen::VectorXd neighborhood_colors = Eigen::VectorXd::Zero(V.rows());
                for (int vid : neighborhood) {
                    if (vid < V.rows()) {
                        neighborhood_colors(vid) = 1.0;
                    }
                }
                visualize_scalar_field(neighborhood_colors, "Voisinage " + std::to_string(k_rings) + "-rings");
                return true;
            }
            case 'r':
                viewer.data().set_colors(Eigen::RowVector3d(0.9, 0.9, 0.9)); // Couleur par dÃ©faut
                return true;
        }
        return false;
    };
    
    // Affichage initial
    visualize_scalar_field(laplacian_values, "Laplacien par diffusion (initial)");
    
    // Instructions pour l'utilisateur
    std::cout << "\n=== CONTRÃ”LES ===" << std::endl;
    std::cout << "1: Afficher Laplacien par diffusion" << std::endl;
    std::cout << "2: Afficher Laplacien par systÃ¨me linÃ©aire" << std::endl;
    std::cout << "3: Afficher voisinage " << k_rings << "-rings du sommet " << selected_vertex << std::endl;
    std::cout << "r: RÃ©initialiser couleur" << std::endl;
    std::cout << "=================" << std::endl;
    
    // Lancer la visualisation
    viewer.launch();
    
    return 0;
}